{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _simpleUpdateIn = _interopRequireDefault(require(\"simple-update-in\"));\nvar _EventSpy = _interopRequireDefault(require(\"../EventSpy\"));\nvar _FunctionContext = _interopRequireDefault(require(\"./FunctionContext\"));\nvar _InternalContext = _interopRequireDefault(require(\"./InternalContext\"));\nvar _SpineTo = _interopRequireDefault(require(\"../SpineTo\"));\nvar _StateContext = _interopRequireDefault(require(\"./StateContext\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return setInterval(fn, ms);\n}\nfunction computeViewState(_ref) {\n  var mode = _ref.stateContext.mode,\n    _ref$target = _ref.target,\n    offsetHeight = _ref$target.offsetHeight,\n    scrollHeight = _ref$target.scrollHeight,\n    scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === 'top' ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: !atEnd,\n    atTop: atTop\n  };\n}\nvar Composer = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Composer, _React$Component);\n  function Composer(props) {\n    var _this;\n    _classCallCheck(this, Composer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleScrollEnd = _this.handleScrollEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._ignoreScrollEventBefore = 0;\n    _this.state = {\n      functionContext: {\n        scrollTo: function scrollTo(scrollTop) {\n          return _this.setState(function (_ref2) {\n            var stateContext = _ref2.stateContext;\n            return {\n              scrollTop: scrollTop,\n              stateContext: (0, _simpleUpdateIn.default)(stateContext, ['animating'], function () {\n                return true;\n              })\n            };\n          });\n        },\n        scrollToBottom: function scrollToBottom() {\n          return _this.state.functionContext.scrollTo('100%');\n        },\n        scrollToEnd: function scrollToEnd() {\n          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),\n            _assertThisInitialize2 = _assertThisInitialize.state,\n            functionContext = _assertThisInitialize2.functionContext,\n            stateContext = _assertThisInitialize2.stateContext;\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: function scrollToStart() {\n          var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this)),\n            _assertThisInitialize4 = _assertThisInitialize3.state,\n            functionContext = _assertThisInitialize4.functionContext,\n            stateContext = _assertThisInitialize4.stateContext;\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: function scrollToTop() {\n          return _this.state.functionContext.scrollTo(0);\n        }\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: function setTarget(target) {\n          return _this.setState(function () {\n            return {\n              target: target\n            };\n          });\n        }\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n    return _this;\n  }\n  _createClass(Composer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.enableWorker();\n    }\n  }, {\n    key: \"disableWorker\",\n    value: function disableWorker() {\n      clearInterval(this._stickyCheckTimeout);\n    }\n  }, {\n    key: \"enableWorker\",\n    value: function enableWorker() {\n      var _this2 = this;\n      clearInterval(this._stickyCheckTimeout);\n      var stickyButNotAtEndSince = false;\n      this._stickyCheckTimeout = setImmediateInterval(function () {\n        var state = _this2.state;\n        var sticky = state.stateContext.sticky,\n          target = state.target;\n        if (sticky && target && !computeViewState(state).atEnd) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.disableWorker();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState(function (_ref3) {\n        var stateContext = _ref3.stateContext;\n        return {\n          stateContext: _objectSpread({}, stateContext, {\n            mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n          })\n        };\n      });\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(_ref4) {\n      var _this3 = this;\n      var timeStampLow = _ref4.timeStampLow;\n\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n      if (timeStampLow <= this._ignoreScrollEventBefore) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n        return;\n      }\n      this.disableWorker();\n      this.setState(function (state) {\n        var target = state.target;\n        if (target) {\n          var internalContext = state.internalContext,\n            scrollTop = state.scrollTop,\n            stateContext = state.stateContext;\n          var _computeViewState = computeViewState(state),\n            atBottom = _computeViewState.atBottom,\n            atEnd = _computeViewState.atEnd,\n            atStart = _computeViewState.atStart,\n            atTop = _computeViewState.atTop;\n          var nextInternalContext = internalContext;\n          var nextStateContext = stateContext;\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atBottom'], function () {\n            return atBottom;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atEnd'], function () {\n            return atEnd;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atStart'], function () {\n            return atStart;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atTop'], function () {\n            return atTop;\n          }); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n          // We need to ignore these \"synthetic\" events\n          // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n          //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n\n          var offsetHeight = target.offsetHeight,\n            scrollHeight = target.scrollHeight;\n          var resized = offsetHeight !== internalContext.offsetHeight;\n          var elementChanged = scrollHeight !== internalContext.scrollHeight;\n          if (resized) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['offsetHeight'], function () {\n              return offsetHeight;\n            });\n          }\n          if (elementChanged) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['scrollHeight'], function () {\n              return scrollHeight;\n            });\n          } // Sticky means:\n          // - If it is scrolled programatically, we are still in sticky mode\n          // - If it is scrolled by the user, then sticky means if we are at the end\n          // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n          if (!resized && !elementChanged) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['sticky'], function () {\n              return stateContext.animating ? true : atEnd;\n            });\n          } // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n          // \"animating\" is used to calculate the \"sticky\" property\n\n          if (scrollTop === null) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['animating'], function () {\n              return false;\n            });\n          }\n          return _objectSpread({}, internalContext === nextInternalContext ? {} : {\n            internalContext: nextInternalContext\n          }, stateContext === nextStateContext ? {} : {\n            stateContext: nextStateContext\n          });\n        }\n      }, function () {\n        _this3.state.stateContext.sticky && _this3.enableWorker();\n      });\n    }\n  }, {\n    key: \"handleScrollEnd\",\n    value: function handleScrollEnd() {\n      // We should ignore debouncing handleScroll that emit before this time\n      this._ignoreScrollEventBefore = Date.now();\n      this.setState(function () {\n        return {\n          scrollTop: null\n        };\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var handleScroll = this.handleScroll,\n        handleScrollEnd = this.handleScrollEnd,\n        _this$props = this.props,\n        children = _this$props.children,\n        debounce = _this$props.debounce,\n        _this$state = this.state,\n        functionContext = _this$state.functionContext,\n        internalContext = _this$state.internalContext,\n        scrollTop = _this$state.scrollTop,\n        stateContext = _this$state.stateContext,\n        target = _this$state.target;\n      return _react.default.createElement(_InternalContext.default.Provider, {\n        value: internalContext\n      }, _react.default.createElement(_FunctionContext.default.Provider, {\n        value: functionContext\n      }, _react.default.createElement(_StateContext.default.Provider, {\n        value: stateContext\n      }, children, target && _react.default.createElement(_EventSpy.default, {\n        debounce: debounce,\n        name: \"scroll\",\n        onEvent: handleScroll,\n        target: target\n      }), target && scrollTop !== null && _react.default.createElement(_SpineTo.default, {\n        name: \"scrollTop\",\n        onEnd: handleScrollEnd,\n        target: target,\n        value: scrollTop\n      }))));\n    }\n  }]);\n  return Composer;\n}(_react.default.Component);\nexports.default = Composer;\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\nComposer.propTypes = {\n  checkInterval: _propTypes.default.number,\n  debounce: _propTypes.default.number\n};","map":{"version":3,"names":["_propTypes","_interopRequireDefault","require","_react","_simpleUpdateIn","_EventSpy","_FunctionContext","_InternalContext","_SpineTo","_StateContext","MIN_CHECK_INTERVAL","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","setImmediateInterval","fn","ms","setInterval","computeViewState","_ref","mode","stateContext","_ref$target","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","Composer","props","_this","_classCallCheck","_possibleConstructorReturn","_getPrototypeOf","call","handleScroll","bind","_assertThisInitialized","handleScrollEnd","_ignoreScrollEventBefore","state","functionContext","scrollTo","setState","_ref2","default","scrollToBottom","scrollToEnd","_assertThisInitialize","_assertThisInitialize2","scrollToTop","scrollToStart","_assertThisInitialize3","_assertThisInitialize4","internalContext","setTarget","animating","sticky","enableWorker","clearInterval","_stickyCheckTimeout","_this2","stickyButNotAtEndSince","Date","now","Math","max","checkInterval","disableWorker","nextProps","_ref3","_objectSpread","_this3","timeStampLow","_ref4","_computeViewState","nextInternalContext","nextStateContext","resized","elementChanged","_this$props","children","debounce","_this$state","createElement","Provider","value","name","onEvent","onEnd","Component","defaultProps","propTypes","number"],"sources":["E:\\Third_Year\\SDL\\React-ChatApp\\client-user\\node_modules\\react-scroll-to-bottom\\src\\ScrollToBottom\\Composer.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport updateIn from 'simple-update-in';\n\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport StateContext from './StateContext';\n\nconst MIN_CHECK_INTERVAL = 17;       // 1 frame\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ stateContext: { mode }, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n  const atEnd = mode === 'top' ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart: !atEnd,\n    atTop\n  };\n}\n\nexport default class Composer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleScroll = this.handleScroll.bind(this);\n    this.handleScrollEnd = this.handleScrollEnd.bind(this);\n\n    this._ignoreScrollEventBefore = 0;\n\n    this.state = {\n      functionContext: {\n        scrollTo: scrollTop => this.setState(({ stateContext }) => ({\n          scrollTop,\n          stateContext: updateIn(stateContext, ['animating'], () => true)\n        })),\n        scrollToBottom: () => this.state.functionContext.scrollTo('100%'),\n        scrollToEnd: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: () => this.state.functionContext.scrollTo(0)\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: target => this.setState(() => ({ target }))\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    this.enableWorker();\n  }\n\n  disableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n  }\n\n  enableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n\n    let stickyButNotAtEndSince = false;\n\n    this._stickyCheckTimeout = setImmediateInterval(\n      () => {\n        const { state } = this;\n        const { stateContext: { sticky }, target } = state;\n\n        if (\n          sticky\n          && target\n          && !computeViewState(state).atEnd\n        ) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      },\n      Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL\n    );\n  }\n\n  componentWillUnmount() {\n    this.disableWorker();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState(({ stateContext }) => ({\n      stateContext: {\n        ...stateContext,\n        mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n      }\n    }));\n  }\n\n  handleScroll({ timeStampLow }) {\n    // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= this._ignoreScrollEventBefore) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n      return;\n    }\n\n    this.disableWorker();\n\n    this.setState(state => {\n      const { target } = state;\n\n      if (target) {\n        const { internalContext, scrollTop, stateContext } = state;\n        const { atBottom, atEnd, atStart, atTop } = computeViewState(state);\n        let nextInternalContext = internalContext;\n        let nextStateContext = stateContext;\n\n        nextStateContext = updateIn(nextStateContext, ['atBottom'], () => atBottom);\n        nextStateContext = updateIn(nextStateContext, ['atEnd'], () => atEnd);\n        nextStateContext = updateIn(nextStateContext, ['atStart'], () => atStart);\n        nextStateContext = updateIn(nextStateContext, ['atTop'], () => atTop);\n\n        // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n        // We need to ignore these \"synthetic\" events\n        // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n        //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n        const { offsetHeight, scrollHeight } = target;\n        const resized = offsetHeight !== internalContext.offsetHeight;\n        const elementChanged = scrollHeight !== internalContext.scrollHeight;\n\n        if (resized) {\n          nextInternalContext = updateIn(nextInternalContext, ['offsetHeight'], () => offsetHeight);\n        }\n\n        if (elementChanged) {\n          nextInternalContext = updateIn(nextInternalContext, ['scrollHeight'], () => scrollHeight);\n        }\n\n        // Sticky means:\n        // - If it is scrolled programatically, we are still in sticky mode\n        // - If it is scrolled by the user, then sticky means if we are at the end\n\n        // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n        if (!resized && !elementChanged) {\n          nextStateContext = updateIn(nextStateContext, ['sticky'], () => stateContext.animating ? true : atEnd);\n        }\n\n        // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n        // \"animating\" is used to calculate the \"sticky\" property\n        if (scrollTop === null) {\n          nextStateContext = updateIn(nextStateContext, ['animating'], () => false);\n        }\n\n        return {\n          ...internalContext === nextInternalContext ? {} : { internalContext: nextInternalContext },\n          ...stateContext === nextStateContext ? {} : { stateContext: nextStateContext }\n        };\n      }\n    }, () => {\n      this.state.stateContext.sticky && this.enableWorker();\n    });\n  }\n\n  handleScrollEnd() {\n    // We should ignore debouncing handleScroll that emit before this time\n    this._ignoreScrollEventBefore = Date.now();\n\n    this.setState(() => ({ scrollTop: null }));\n  }\n\n  render() {\n    const {\n      handleScroll,\n      handleScrollEnd,\n      props: { children, debounce },\n      state: { functionContext, internalContext, scrollTop, stateContext, target }\n    } = this;\n\n    return (\n      <InternalContext.Provider value={ internalContext }>\n        <FunctionContext.Provider value={ functionContext }>\n          <StateContext.Provider value={ stateContext }>\n            { children }\n            {\n              target &&\n                <EventSpy\n                  debounce={ debounce }\n                  name=\"scroll\"\n                  onEvent={ handleScroll }\n                  target={ target }\n                />\n            }\n            {\n              target && scrollTop !== null &&\n                <SpineTo\n                  name=\"scrollTop\"\n                  onEnd={ handleScrollEnd }\n                  target={ target }\n                  value={ scrollTop }\n                />\n            }\n          </StateContext.Provider>\n        </FunctionContext.Provider>\n      </InternalContext.Provider>\n    );\n  }\n}\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  debounce: PropTypes.number\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}